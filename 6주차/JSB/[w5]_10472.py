# -*- coding: utf-8 -*-
"""[W5]_10472.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gNp-j_7cb68kK-l8fL0bI21fOE-VRXxo
"""

# W5 10472 십자뒤집기

from itertools import product  # 모든 조합을 생성시키는 모듈

def flip(board, x, y): # 보드 색상 반전 함수
    for dx, dy in [(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)]: # 현위치, 상, 하, 좌, 우 순회
        nx, ny = x + dx, y + dy
        # 새로운 좌표 (nx, ny)가 보드의 범위 안에 있는지 확인
        if 0 <= nx < 3 and 0 <= ny < 3:
            board[nx][ny] = '*' if board[nx][ny] == '.' else '.' # 색상 반전

def solve(board):
    min_clicks = float('inf')  # 최소 클릭 수 초기화

    # 3x3 보드의 각 칸에 대해 클릭할지 말지의 모든 조합을 생성
    for clicks in product([0, 1], repeat=9):
        temp_board = [row[:] for row in board]  # 현재 보드를 복사
        click_count = 0  # 현재 조합의 클릭 횟수를 초기화

        # 클릭 조합을 적용
        for idx, click in enumerate(clicks):
            if click: # 클릭하는 경우
                x, y = divmod(idx, 3)  # idx를 3으로 나눈 몫과 나머지를 좌표로 변환
                flip(temp_board, x, y)  # 해당 좌표를 클릭하여 보드를 반전시킴
                click_count += 1

        # 모든 칸이 흰색인지 확인
        if all(temp_board[i][j] == '.' for i in range(3) for j in range(3)):
            min_clicks = min(min_clicks, click_count) # 최소 클릭 수 갱신

    return min_clicks


## __main__ ##
P = int(input())  # 테스트 케이스 수

for _ in range(P):
    board = [list(input().rstrip()) for _ in range(3)] # 보드 입력
    print(solve(board))